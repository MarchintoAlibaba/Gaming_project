var reg=/is\b/gi  全局匹配后面有空格符的大小写不铭感的is字符  后面加 m 表示多行搜索

元字符
\s 空白符 \0 空字符 \t水平制表符 \v 垂直制表符 \n换行符 \r回车符	 
[abc] 表示只要有a、b、c任意一个都可以 [^abc]与前面相反
范围类
[a-z]和[a-zA-Z0-9]
预定义类
. 表示出了回车符和换行符之外的任意字符 \d和[0-9]都是数字字符 \D非数字字符 \s 空白符 \S非空白符
\w单词字符(字母、数字下划线) \W非单词字符
边界字符
\b 单词边界 ^以什么开始 $以什么结束
量词
？出现零次或一次 +出现一次或多次 *出现零次或多次 {n} 出现n次 {n,m}出现n到m次 {n,} 至少出现n次
列 '12345678'.replace(/\d{3,6}/g,'X') =>X78 这是正常的贪婪模式 '12345678'.replace(/\d{3,6}?/g,'X') =>XX78 这是非贪婪模式 只要一匹配到就替换
分组
(byaron){3} 匹配byaron连续出现三次
反向引用
‘2016-11-25'.replace(/(\d{4})-(\d{2})-(\d{2})/,'$2/$3/$1')=>11-25-2016
 前瞻
正向前瞻：exp(?=assert) 负向前瞻：exp(?!assert)
列正向前瞻
'a2*34v8'.replace(/\w(?=\d)/g,'X')=>X2*X4X8  意思就是匹配一个要满足后面是数字的单词字符
负向前瞻是匹配一个不后面不是数字的单词字符
方法 test
var reg1=/\w/   reg1.test('a')=>true
方法 exec
var reg2=/\w/   var ret=reg2.exec('a')=>true  ret.lastindex:表示匹配对象的最后一个字符的下一个字母      ret.index:表示从第几个字符开始匹配  ret.toString():第一项表示匹配的对象 第二个表示第一个分组的对象

1343691474